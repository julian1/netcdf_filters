
tinyscheme
ts> (+ 2 3 4)
ts> (string-append "hi" "there")

--------

subsetted netcdf generation 

- take the code to the server
----------------

values that become dijoint due to filters. eg. filtered over spatial extent, same series enters and leaves.


- jdbc connection - that we can execute.  
- jdbc connection configuration. 

- string test expression.
- find a basic java calc example. or parse ourselves based on cql.  

- typing

- ahhh. 
- temporal type will just be date - ok.
- spatial extent - will need to parse a geometry representation, or the postgres operators 
- might be easier to adopt prefix notation
- contains( geom, ). 
- think we need to construct a couple of sql examples to see what the sql looks like


- library


- name<value,field
- assemble a single netcdf and stream zip ?   

- we have to use geometry because that is the field where that has the spatially indexed value. 
 
	
Mapping from filter syntax -> sql 
- double, date, geometry 
- use an ast? 
- should we write in ocaml as first pass...


- lisp-like to be syntax agnostic. allow us to code up geometry easily as well.

layer=xxx& filter= and ( contains(geom, box( (0,0), ... ), less ( time , 1.1.2015 ) 

- we could actually expose post db transform as well.

- we can expose any of the postgres st functions/operators if we want with this type of syntax.
-


	lispy 
		syntax agnostic, during development 
		ability to parse as ast without complication
		avoid sql injection attack
		very simple tree...

- need to control input, before sql generation? actually it doesn't matter if the sql filter action 
fails at runtime due to typing issues etc.

- basic types are int,double,date, geom representations.
- might have a sub-parser for date types?

node
	symbol
	children

parse_int
parse_identifier 
parse_children
parse_tuple ?

think we need a tokenizer - '(' ')' ints, date, geom

expr = parse_identifer  parse_children
----

sql argument substitution will need to be dynamic...  uggh...
	rather than $1, $2, $3
	no it should be ok.





